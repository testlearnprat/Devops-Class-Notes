---------------------------------------------------------------------------------------------------------------
Kubernetes
---------------------------------------------------------------------------------------------------------------
10-12-22 - class 2
---------------------------------------------------------------------------------------------------------------
Installation:

Link: https://github.com/artisantek/kubernetes-installation

kubectl  --> k8s controll line commands
kubectl get nodes --> To check all the nodes on the cluster

kubectl label node <node-name> node-role.kubernetes.io/worker1= --> To give a role to a node
kubectl label node <node-name> node-role.kubernetes.io/worker1-  --> to remove label
---------------------------------------------------------------------------------------------------------------
Pod Definition File:

apiVersion: v1
kind: Pod
metadata:
  name: nginx
spec:
  containers:
  - name: nginx
    image: nginx
    ports:
    - containerPort: 80
---------------------------------------------------------------------------------------------------------------
Commands:

kubectl apply -f <file>.yaml --> To apply a configuration in kubernetes
0r 
kubectl create -f <file>.yaml --> To apply a configuration in kubernetes

kubectl get pods --> To list the pods in the cluster
kubectl get pods -o wide --> to list in wide format
kubectl get po -o json/yaml/-w --> -w to watch continuos
kubectl get pods -l <label>  --> to list pods with such labels
ex: kubectl get pods -l env=dev
kubectl get pods -n <namespacename>  --> to list pods in namespace


kubectl describe <object-kind> <name> --> To see information about a kubernetes object
kubectl delete <object-kind> <name> --> To delete a kubernetes object
example: kubectl delete pod <nameof the pod>

kubectl get deploy -->
kubectl delete deploy --> to delete controller
kubectl apply -f test.yml --> to start the deployer
kubectl get rs
kubectl scale deploy nginx-deployment --replicas 5
---------------------------------------------------------------------------------------------------------------

Manifest file fields:
apiVersions: ex: v1, apps/v1, policy/v1, scheduling.k8s.io/vi, autoscaling,storage  etc
It specifies the version of k8 api to be used for creating k8 objects. It can be v1, app/v1 etc
kubectl api-versions --> to list api versions
kubectl api-resources --api-group <api-version-name> --> to check the objects that can be created by a particular version

kind:
It specifies the type of k8 object to be created. It can be pod, service etc
ex: pod , service, deployment etc

metadata:
It is used to set information about the objects like name, namespace-under which the object will be running etc

spec: 
It consists of core information i.e the desired state of the object 

labels:
they are key value pairs attached to a k8 object which are useful in grouping and selecting the objects
ex:
labels:
  app: nginx
  os: ubuntu


selectors: 
They are used to identify the k8 objects using their labels. 
There are 2 types of selectors in k8: 
1)Equity based selectors: Used to identify objects by key and then exact value. operators allowed are: =, ==, !=
ex: app = nginx , os = ubuntu
2) Set based selectors: used to identify objects by keys based on a set of values. Operators allowed are : in, notin, exists
ex: app in (nginx, tomcat, jenkins) , environment in (dev, test, prod)
kubectl get pods -l 'app in (dev, test, prod)'

------------------------------------------------------------------------------------
CONTROLLERS:

Replica sets/ Replication controller
They are used to create multiple instances of a single pod to achieve load balancing and high availability
If any pod gets deleted then the controller will recreate a new pod

Diff between replica set / replication controller 
Both are used to create multiple replicas of pod. The replication controller(v1) only supports equity selectors while the replica set supports both set based and equity based selector.

apiVersion: apps/v1
kind: ReplicaSet
metadata:
  name: nginx-rs
spec:
  replicas: 3
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      name: nginx
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx
        ports:
        - containerPort: 80


kubectl scale rs <name>  --replicas=10  --> to change number of replicas

for set based:
matchExpressions:
(key: app operator: in, values: )

replica set uses recreate update strategy
deployment uses rolling update strategy
---------------------------------------------------------------------------------------------------------------

Deployment controller: Its the most common object used for deploying applications in kubernetes . With deployment controller we can effortleslly rollout application updates and rollback the updates without breaking the user experiance.

Deployment Controller:

apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deploy
spec:
  replicas: 3
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      name: nginx
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx
        ports:
        - containerPort: 80

Commands:

kubectl set image deploy nginx-deploy nginx=nginx:1.14 --record --> To update the image using Deployment Controller

kubectl rollout history deploy nginx-deploy --> To check the total recorded hostory of the Controller

kubectl rollout undo deploy nginx-deploy --> To roll back to a previous version of the application
kubectl rollout undo deploy nginx-deploy --to-revision=1 --> To roll back to a particular revision number

kubectl scale deploy nginx-deploy --replicas=5 --> To scale the pods
---------------------------------------------------------------------------------------------------------------

Daemon -> Daemon set controller ensures that a pod runs on all the nodes of the cluster , if a node is added or removed from
 a cluster daemon set automatically adds or deletes the pods.
Typical use cases: 
1) Monitoring exporters: Monitoring apps like Nodeexporter, Prometheus use daemon set to monitor all the nodes in our cluster
2) Logs collection: Fluentd application collects the logs from all the nodes using daemon set 

:StatefullSet Controller: Like a deployment cntroller, statefullset also manages pods that are based on an identical container 
specification unlike deployment statefullset maintains uniqe identity for each oftheir pods, i.e the pods that are created will 
have their own state and their own volume  

use efs mount on all pods, nfs, clusterfs to replicate data in all pods as an alternative for statefull

Stateless application : applications which donot store any data in them....all pods share common storage unit in backend



Pod Phases/Pod Lifecycle: The phase of a pod  is a simple high level summary ehere the pod is in its lifecycle 
1) Pending --> The pod has been accepted by the k8 cluster  but one or more containers present inside the pod have not yet been started 
2)Running --> The pod has been scheduled to a node and all the containers have been created and up and running
3)Succeeded --> All the containers in the pod  have terminated in successs and will not be restarted 
4)Failed --> All the containers in the pod have terminated but atleast one container has terminated in failure i.e the container exited with non zero status
5) Unknown --> The pod goes to  unknown state if the state of the pod could not be obtained due to an error in communicating with node where pod was running 
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

PROBES: Probes are the actions performed by the kubelet which help in monitering and checking the condition of the applications inside the pods.
They are defined at the container level and we can define multiple probes in the manifest file.

Probe Types: 
1) Readiness probe: with readiness probe if the conditions configured in the manifest file fail,the application or the pod are not allowed to serve external requests.
2)Liveness probe: Rather then just stopping the pods to serve the external requests like readiness probe, liveness probe incase of faiure it kills the container and 
restarts it which might have the application to get back to its initial healthy state
3)Startup probe


Configuribg probe: 
1)initialDelaySeconds [Default-0, Min-0]:  It is the number of seconds between the container start and the first probe action.
2)periodSeconds [Default-10, Min-1]: -- it is the frequency in seconds of the probe action after the initial delay time
3)timeoutSeconds [Default-1, Min-1]: It is a number of seconds the probe waits for a response from pod before assuming failure 
4)SuccessThreshold [Default-1, Min-1]: The number of consecutive positive responses needed to switch probe status to success 
5)failureThreshold [ default-1, Min-1]: - the number of consecutive negative responses needed to assume the pod has failed 

Probe Actions:
1. Shell[exec]: This probe acton is used to run shell commands inside the pods and the response is considered failure if the command exits with non zero value 
syntax:

<probe-type>
  exec:
  command:
  - command1
  - command2

Example:

apiVersion: v1
kind: Pod
metadata:
  name: alpine
  labels: 
    app: alpine
spec:
  containers:
  - name: alpine
    image: alpine
    args:
    - /bin/sh
    - -c
    - touch /home/probecheck; sleep 15; rm /home/probecheck; sleep 10000000
    livenessProbe:
      exec:
        command:
        - cat
        - /home/probecheck
      initialDelaySeconds: 2
      periodSeconds: 3
      failureThreshold: 3


2) HTTP Request [httpget]: This probe action sends an http get request to the path defines inside the probe , the http response code determines whether the probe is successfull or not.
syntax:
<probe-type>
  httpGet:
    path: <path-inside-container>
    port: <port>

apiVersion: v1
kind: Pod
metadata:
  name: liveness
  labels: 
    app: probe
spec:
  containers:
  - name: liveness
    image: registry.k8s.io/liveness
    args:
    - /server
    livenessProbe:
      httpGet:
        path: /healthz
        port: 8080
      initialDelaySeconds: 2
      periodSeconds: 3
      failureTreshold: 3

3) TCP Port Check [tcpSocket]: --> This probe action is used to check if a port of the pod is open and if the kubelet can connect to that specific port 
syntax: 
<probe-type>
  tcpSocket:
    port: <port-number>

apiVersion: v1
kind: Pod
metadata:
  name: nginx
  labels: 
    app: nginx
spec:
  containers:
  - name: nginx
    image: nginx
    ports:
    - containerPort: 80
    readinessProbe:
      tcpSocket:
        port: 100

Startup Probe [1.16]:
Both startup and livenessprobe have same properties i.e incase of failure they restart the container.
If both strtup and liveness probe are set, after container creation kubelet will execute startup probe first, if startup probre succeeds than liveness probe takes over further action. if startup probe fails the pod is restarted and the cycle is repeated. It is an extra layer of check for the pods



